/*
 * 题意：
 * 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 
 * 返回你可以获得的最大乘积。
 *
 * 思路：
 * 1. 贪心策略
 * 1.1 当分解因子中有加法因子“1”的时候
 * 1x(n-1) = n-1 < n 分解出1只会让乘积变得更小
 * 
 * 1.2 当分解因子中有加法因子“2”的时候
 * 如果 2*(n-2) > n 得出 n > 4，所以当n>4时，分解出2这个因子然后和n-2相乘 肯定大于n
 * 
 * 1.3 当分解因子中有加法因子“3”的时候
 * 如果 3*(n-3) > n 得出 n > 4.5，所以当n>4.5时，分解出3这个因子然后和n-3相乘 肯定大于n
 * 
 * 1.4 当分解因子中有加法因子“4”的时候
 * 比较以下四种情况的大小————n、4*(n-4)、2*2*(n-4)、1*3*(n-4)
 * 最后一种1*3*(n-4)不用考虑，因为分解出了1，会使乘积变小
 * 当n>5.3时，4*(n-4)>n
 * 明显看出 4*(n-4) = 2*2*(n-4) > 1*3*(n-4)
 * 结论：如果分解因子中包含“4”，等价于分解出2个“2”，可以将其归类到分解出“2”的情况，所以没有必要分解出“4”
 * 
 * 1.5 当分解因子中有加法因子“5”的时候
 * 比较以下四种情况的大小————n、5*(n-5)、2*3*(n-5)、1*4*(n-5)
 * 最后一种 1*4*(n-5) 不用考虑，因为分解出了1，会使乘积变小
 * 当n>6.25时，5*(n-5) > n
 * 明显看出 2*3*(n-5) > 5*(n-5) > 1*4*(n-5)
 * 结论：如果分解因子中包含“5”，不如分解出“2”和“3”，可以将其归类到分解出“2”和“3”的情况，所以没有必要分解出“5”
 * 
 * 1.6 当分解因子中有加法因子“6”的时候
 * 明显看出 6*(n-6) < 2*2*2*(n-6) < 3*3*(n-6)
 * 结论：如果分解因子中包含“6”，不如分解出“3”和“3”，可以将其归类到分解出“3”的情况，所以没有必要分解出“6”
 * 
 * 以此类推：
 * 7×(n−7) < 2×2×3×(n−7)  8×(n−8) < 2×3×3×(n−8)  9×(n−9) < 3×3×3×(n−9)
 * 结论：
 * 4及4以上的所有正整数因子都不用考虑，因为它们都可以归类到分解出“2”和“3”的情况中去
 * 又因为当  n>=5时，3*(n-3) > 2*(n-2)
 * 所以在进行分解时，当n大于4的时候，尽可能多的分解出“3”，当n小于等于4时，直接给出答案即可。
 * 
 * 2. 动态规划法
 * 令 dp[i] 代表 n = i 时，拆分后可获得的最大乘积。
 * 可以获得几个初始值 dp[0] = 0, dp[1] = 1, dp[2] = 1
 * 递推公式  dp[i] = max(2 * max(dp[i-2], i-2), 3 * max(dp[i-3], i-3))
 * 含义：
 * 根据上述贪心法中的分析，如果n大于等于4，都可以将其变成分解出1，2和3的子问题(可以不考虑1，因为分解出1后肯定变小)
 * 当分解出2时，n-2 和 dp[n-2] 中大的那一个数乘以2就是分解出2和n-2时的最大值
 * 当分解出3时，n-3 和 dp[n-3] 中大的那一个数乘以3就是分解出3和n-3时的最大值
 * 求乘积大的那一个就是当前n对应的拆分后可获得的最大乘积
 */

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

// 贪心法
int integerBreak(int n) {
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    if (n == 4)
        return 4;
    int res = 1;
    while (n > 4) {
        res *= 3;
        n -= 3;
    }
    res *= n;
    return res;
}

// 动态规划法
int integerBreak(int n) {
    if (n <= 3) {
        return n-1;
    }
    vector<int> dp(n+1, 0);
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 1;

    for (int i = 3; i < n+1; ++i) {
        dp[i] = max(2 * max(dp[i-2], i-2), 3 * max(dp[i-3], i-3));
    }
    return dp[n];
}



int main() {
    int num = 10;
    auto ret = integerBreak(num);
    cout << ret << endl;
    return 0;
}