/*
 * 题意：
 * 初始时有 n 个灯泡关闭。 
 * 第 1 轮，你打开所有的灯泡。 
 * 第 2 轮，每两个灯泡你关闭一次。 
 * 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。
 * 第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 
 * 找出 n 轮后有多少个亮着的灯泡。
 *
 * 思路：
 * 对于第k个灯泡，只有当次数是k的因子时，才能改变灯泡的状态，即k能被当前次数整除
 * 比如当k为36时，它的因数有(1,36), (2,18), (3,12), (4,9), (6,6), 可以看到前四个括号里成对出现的因数各不相同
 * 括号中前面的数改变了灯泡状态，后面的数又变回去了，等于灯泡的状态没有发生变化
 * 只有最后那个(6,6)，在次数6的时候改变了一次状态，没有对应其它的状态能将其变回去了，所以灯泡就一直是点亮状态的。
 * 
 * 规律：
 * 只有当一个数的因数成对出现偶数次时，该灯泡最后还是和初始状态一样。如6的因数(1,6)(2,3)
 * 只有当一个数的因数成对出现奇数次时，该灯泡最后和初始状态不一样。如16的因数(1,16)(2,8)(4,4)
 * 只有完全平方数有这么一个相等的因数对，即所有平方数的灯泡都将会是点亮的状态。
 * 
 * 所以该题所求的值为包括n以内的完全平方数的个数
 */

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int bulbSwitch(int n) {
    int res = 1;
    while (res * res <= n) {
        res++;
    }
    return res-1;
    //return sqrt(n);
}

int main() {
    int n = 5;
    auto numbers = bulbSwitch(n);
    cout << numbers << endl;
    return 0;
}