/*
 * 题意：
 * 有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。
 * 问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？
 * 
 * 回答这个问题，并为下列的进阶问题编写一个通用算法。
 * 假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出 “有毒” 水桶？
 * 这 n 只水桶里有且仅有一只有毒的桶。
 * 
 * 思路：
 * 考虑题目中的情况，如果15分钟为一个冷却期，那么1个小时之内最多只能喂 60/15=4 次水
 * （1）如果0分钟的时候喂0号桶，15分时死去，说明0号桶有毒
 * （2）如果没有死亡，15分钟的时候喂1号桶，30分时死去，说明1号桶有毒
 * （3）如果没有死亡，30分钟的时候喂2号桶，45分时死去，说明2号桶有毒
 * （4）如果没有死亡，45分钟的时候喂3号桶，60分时死去，说明3号桶有毒
 * （5）如果没有死亡，说明4号桶有毒
 * 根据上述推测，如果只有1只猪，那么最多只能验证5个桶
 * 如果有2只猪，可以验证 pow(5,2)=25 桶水，方法如下
 *        0-15    15-30    30-45    45-60
 *  0-15 |  0       1        2        3        4        
 * 15-30 |  5       6        7        8        9
 * 30-45 |  10      11       12       13       14
 * 45-60 |  15      16       17       18       19
 *       |  20      21       22       23       24
 * 第一只猪（横起来的行）在第0分钟喂0/5/10/15/20这5桶水的混合水，以此类推一共喂食4次
 * 第二只猪（竖起来的列）在第0分钟喂0/1/2/3/4这5桶水的混合水，以此类推一共喂食4次
 * 如果第一只猪在30-45分钟死亡，第二只猪在15-30分钟死亡，那么说明7号桶有毒（两条线的交点）
 * 如果第一只猪在45-60分钟死亡，第二只猪没有死亡，那么说明23号桶有毒
 * 
 * 根据以上推理，对于通用问题来讲，如果m分钟内死亡，那么p分钟内一共可以喂水 p/m 次
 * 那么一只猪能推断出 p/m+1 桶水哪一桶有毒
 * 那么可以认为一只猪可以携带 p/m+1 的信息量
 * 那么就有公式：pow(p/m+1, x) = n
 * 计算出 x = ceil(log(n) / log(p/m+1))
 */

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    int times = minutesToTest / minutesToDie;
    int base = times + 1;
    int answer = ceil(log(buckets) / log(base));
    return answer;
}

int main() {
    auto ret = poorPigs(4, 15, 15);
    cout << ret << " "; // 2
    return 0;
}
