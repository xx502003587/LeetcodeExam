/*
 * 题目：
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 *
 * 思路：
 * 1. 常规思路————首先判断最右边一位是不是1，然后将整个数右移一位，继续判断，直到该数变为0
 * 该方法容易引起死循环，正数在右移时，最高位会补0
 * 但是负数在右移时为了保证还是一个负数，所以会在最高位补1
 * 2. 当把一个整数减去1后，它二进制的最右边的1会变成0，然后右边的0全部变成1，此时将这个整数和比它小1的整数做与运算后，该整数最右边的那个1就被去掉了。
 * 如：12 = 1100，11 = 1011，12&11 = 1000
 * 也就是说当n变为0之前，每一次与操作都会把最右边的那个1去掉，一共去多少次就有多少个1
 */

#include <iostream>

using namespace std;

int  NumberOf1(int n) {
    int count = 0;
    while (n) {
        ++count;
        n = (n-1) & n;
    }
    return count;
}

int main() {
    auto ret = NumberOf1(12);
    cout << ret << endl;
    return 0;
}