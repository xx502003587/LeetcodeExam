/*
 * 题意：
 * 现有一个数列A{a1,a2,a3,...,an}，对于这个数列，仅可以通过一种操作来改变它
 * 任意选择两个数，从数列中删除，然后将这两个数的和作为一个新的元素加入数列尾部
 * 现在的问题是，在操作至多k次的情况下，数列中能被3整除的数最多有多少个
 *
 * 思路：
 * 因为题目所求的是最多有多少个，所以如果数列中的数都可以被3整除的话，就可以停止操作，此时的数是最多的，一旦继续操作就会变少
 * 1. 首先将数列中的所有数对3取余，将数列变成仅由0，1，2组成的数列
 * 2. 先统计0的个数cnt0，cnt0 = 未操作前数列中能被3整除的个数
 * 3. 因为每次任意选择的是两个数，要保证两数的和能被3整除，只能选择1个1和1个2，所以能产生被3整除的数个数一定是1和2数量中少的那一个
 * 统计1和2的个数cnt1和cnt2，挑出两数中小的那个 t = min(cnt1, cnt2)，此时和k比大小：
 * 如果 t 比 k 大，那么所求的结果应该为 cnt0 + k。因为至多操作k次，而可以生成的数量又大于k，所以相当于直接生成k个，剩下的不管，算法结束
 * 如果 t 比 k 小，表明从数列中删除t个1和t个2，可以生成t个3，然后操作次数还剩 k-t 次
 * 4. 如果之前统计1和2个数时，较少的是1，那么数列中现在只剩下0和2
 * 由于每3个2可以产生一个能被3整除的数6，所以先计算能够凑成6的个数，即 2的个数/3；但是因为有操作次数 k-t 的限制，每2次操作可以产生1个6（2+2=4 4+2=6），所以最多只能产生 (k-t)/2个6，所以在二者之间取小，加上之前的个数，就是结果
 * 例：2 2 2 2 2 2 2 当有7个2时，最多只能产生2个6，即7/3=2；当限制操作次数为1时，只能产生0个6；次数为2时，产生1个6
 * 如果统计个数时，较少的是2，那么数列中剩下的就是0和1
 * 由于每3个1可以产生一个能被3整除的数3，所以先计算能够凑成3的个数，即 1的个数/3；但是因为有操作次数 k-t 的限制，每2次操作可以产生1个3（1+1=2 2+1=3），所以最多只能产生 (k-t)/2个3，所以在二者之间取小，加上之前的个数，就是结果
 */

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n = 0, k = 0;
    cin >> n >> k;

    vector<int> nums(n, 0);
    vector<int> temp(n, 0);
    int cnt1 = 0;
    int cnt2 = 0;
    int res = 0;
    for (int i = 0; i < n; ++i) {
        // 
        cin >> nums[i];
        temp[i] = nums[i] % 3;
        if (temp[i] == 1)
            ++cnt1;
        if (temp[i] == 2)
            ++cnt2;
        if (temp[i] == 0)
            ++res;
    }
    int mmin = min(cnt1, cnt2);
    if (mmin < k) {
        res += mmin;
        if (mmin == cnt2) {
            int rest1 = cnt1 - cnt2;
            res += min(rest1 / 3, (k - mmin) / 2);
        } else {
            int rest2 = cnt2 - cnt1;
            res += min(rest2 / 3, (k - mmin) / 2);
        }
    } else {
        res += k;
    }
    cout << res;

    return 0;
}