/*
 * 题意：
 * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 
 * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
 *
 * 思路：
 * 根据丑数的定义，丑数只能被2，3，5整除。
 * 也就是说如果一个数能被2整除，就连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就连续除以5
 * 如果最后得到了1，就表明这个数是丑数
 * 1. 通过遍历每一个数，并传入 IsUgly 的方法来判断一个数是否为丑数，并且在遍历过程中进行计数，直到生成的是第n个即可
 * 
 * 2. 上述通过遍历每一个数来判断的方法十分耗时，因为它要对每一个数进行判断，所以可以试着找到一种计算丑数的方法，从而不在非丑数上花时间。
 * 根据丑数的定义，一个丑数应该是另一个丑数乘以2、3或5的结果（1除外），因此可以创建一个数组，里面的数是排好序的丑数，每一个丑数都是前面的丑数乘以2、3、5得到的
 * 这种思路的关键在于怎么确保数组里的丑数是排好序的。
 * 假设数组中已经有若干个丑数排好序后放在数组中，并且把最大的丑数记为m，接下来考虑如何生成下一个丑数
 * 下一个丑数应该是前面某一个丑数乘以2、3或者5的结果，并且要保证排好序，应该是比m大的最小的一个数
 * 所以首先考虑把已有的每个丑数都乘以2，把得到的第一个乘以2之后大于m的结果记为m2，以此类推可以记为m3和m5，下一个丑数应该是这三个数里面的最小数
 * 
 * 前面的分析中有一个可以优化的地方：在计算下一个时，把已有的每个丑数都乘以2、3、5
 * 事实上这不是必须的，因为已有的丑数都是按顺序放在数组中的
 * 所以对乘以2而言，肯定存在某一个丑数t2，排在它之前的每一个丑数乘以2都比最大的丑数要小
 * 只需要记下这个丑数的位置，同时每次生成新丑数的时候更新这个位置即可（同理t3 t5）
 */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 判断一个数是否为丑数的方法
int IsUgly(int number) {
    while (number % 2 == 0)
        number /= 2;
    while (number % 3 == 0)
        number /= 3;
    while (number % 5 == 0)
        number /= 5;
    return (number == 1);
}

// 找到三个数中的最小数
int findMin(int a, int b, int c) {
    return min(a, min(b, c));
}

int GetUglyNumber_Solution(int index) {
    if (index <= 0) {
        return 0;
    }
    vector<int> ret(index);
    // 第一个丑数是1
    ret[0] = 1;
    // 记录位置来减少乘法的计算次数
    int t2 = 0;
    int t3 = 0;
    int t5 = 0;
    for (int i = 1; i < index; ++i) {
        // 取到三个数中最小的一个作为下一个丑数
        int min = findMin(ret[t2]*2, ret[t3]*3, ret[t5]*5);
        ret[i] = min;
        // 如果t2所指向的丑数乘以2之后和当前最大的丑数相等，就表明比t2小的丑数乘以2不可能大于当前最大的丑数，于是更新t2的位置
        while (ret[t2] * 2 == min)
            ++t2;
        while (ret[t3] * 3 == min)
            ++t3;
        while (ret[t5] * 5 == min)
            ++t5;
    }
    return ret[index-1];
}

int main() {
    int input = 15; //前20个丑数: 1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36
    auto ret = GetUglyNumber_Solution(input);
    cout << ret << endl;

    return 0;
}
