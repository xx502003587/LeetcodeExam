/*
 * 题意：
 * 有n个人，n个位置，每个人都对应一个自己的位置，假设大家随机选择座位
 * 1. 所有人全部没有坐在正确位置上的情况共有多少种？
 * 2. 只有一个人坐在正确位置上的情况共有多少种？
 *
 * 思路：
 * 错排问题又叫“伯努利信封”问题
 * 1. 考虑n个人，他们的编号分别为1、2、3、……、n，对应的正确座位编号为r1、r2、r3、……、rn
 * 将n个人全部坐错的情况总数记为f(n)
 * 假如 1 号错误坐在了 r2 位置，那么接下来的其他情况共分为两种
 * 1.1 如果 2 号错误坐在了 r1 位置，那么其他人的所有错误情况与 1 2 r1 r2 无关，共有 f(n-2) 种情况
 * 1.2 如果 2 号没有坐在 r1 位置，那么相当于除了 1 号之外的 n-1 个人要坐到 n-1 个座位上，共有 f(n-1) 种情况
 * 那么当 1 号坐在 r2 位置上时，共有 f(n-2)+f(n-1) 种情况
 * 同理，如果 1 坐在错误位置上(r2~rn，共 n-1 种错误位置)，每种都有 f(n-2)+f(n-1) 种情况
 * 故 所有人全部坐错的情况共有 (n-1)*(f(n-2)+f(n-1)) 种
 * 对于初始化，
 * f(0)=0，0个人不可能有坐错的情况
 * f(1)=0，1个人也不可能有坐错的情况
 * f(2)=1，2个人全部坐错的情况为1种（互相坐在对方的位置）
 *
 *
 * 2. 只有一个人坐在正确的位置上的情况可由上述情况进行推断
 * 如果一共有n个人，只有一个人坐在正确的位置，说明剩下的 n-1 个人都坐在错误的位置，所以共有 f(n-1) 种情况
 * 坐对的这一个人，一共有 n 种选择，所以总情况数为 n*f(n-1) 种
 */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int compute(int n, vector<int>& nums) {
    nums[2] = 1;
    for (int i = 3; i <= n; ++i) {
        nums[i] = (i-1) * (nums[i-1] + nums[i-2]);
    }
    return nums[n];
}

int main() {
    vector<int> nums(66,0);
    for (int i = 1; i <= 5; ++i) {
        cout << i << "个人，所有人都坐错位置的情况有：" << compute(i, nums)
        << "种，只有一个人坐对位置的情况有：" << i*compute(i-1, nums) << "种" << endl;
    }
    return 0;
}
